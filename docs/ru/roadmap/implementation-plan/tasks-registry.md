# Реестр задач реализации Universo MMOOMM

Этот документ — пошаговый реестр задач по созданию полнофункционального многопользовательского проекта Universo MMOOMM. Здесь фиксируются этапы, задачи и их краткие пояснения. На момент текущей версии детализированы «Этап 1» и «Этап 2» — совершенствование текущего функционала платформы и подготовка базовых пакетов.

## Этап 1. Совершенствование текущего функционала и создание общего функционала платформы

-   **Переработать систему авторизации (Supabase, подготовка к Passport.js)**

    Задача: стабилизировать многопользовательскую авторизацию, исправить обработку и обновление токенов (refresh), консистентно прокидывать аутентификацию на фронт/бэкенд и в экспортируемые приложения. Создать приложения `packages/auth-frontend` и `packages/auth-backend`.

    Детали:

    -   В `packages/auth-backend` реализовать слой абстракции поверх Supabase Auth (валидация access/refresh, ротация, webhook-события), предусмотреть адаптер под Passport.js на будущее.
    -   В `packages/auth-frontend` — UI компонентов входа/регистрации/обновления токена, интеграция с Supabase SDK, хранение/обновление токенов, перехватчики запросов.
    -   Обновить интеграцию аутентификации в `packages/publish-frontend`, `packages/template-engine-backend` (экспорт в PlayCanvas), `packages/multiplayer-colyseus-backend` (JWT в join-параметрах).

-   **Метавселенные: фронт и сервер, связи и роли Unik/Space**

    Задача: создать `packages/metaverse-frontend` и `packages/metaverse-backend` как базовые приложения домена метавселенных. Обеспечить модели связей мета↔мета (дочерние/партнёрские), каталог мета, и связку с Unik/Space.

    Детали:

    -   В `metaverse-backend`: схемы `metaverse.metaverses`, `metaverse.links`, базовый REST (`/metaverses`, `/metaverses/:id/links`, `/overview`).
    -   В `metaverse-frontend`: интерфейсы управления мета, обзор связей, подключение Unik/Space.
    -   Определить архитектурно: Unik как параллельный каталог (не дочерний мета), мета — каталог миров (общих и личных). Уточнить в документации и API связи «мета ↔ unik ↔ space».

-   **Многохолстовая архитектура UPDL: связки Space↔Space/Unik/Metaverse**

    Задача: дать возможность разносить логику на несколько холстов и связывать их.

    Детали:

    -   В `packages/updl/` и/или `packages/updl/imp/*` добавить узлы-ссылки: `SpaceLink` (ссылка на внешний Chatflow/Space), `UnikLink` (подключение набора Space из Unik), `MetaverseLink` (подключение мира целиком).
    -   Реализовать загрузку зависимых графов по ссылке (с контролем версий), отображение на холсте портов связей, валидацию циклов.
    -   Документация: обновить `universo-platformo/updl-nodes/*` и `applications/metaverse/*` по новой архитектуре связей.

-   **Генерация Space (автосборка по описанию), перенос идеи Agent v2 (Flowise 3.x)**

    Задача: добавить в Space кнопку/панель «Сгенерировать логику», чат для постановки задачи и автогенерацию UPDL-графа.

    Детали:

    -   Импортировать концепцию Agent v2 (Flowise 3.x) в `packages/updl` → один конструктор (без разделения Chatflow/Agentflow): промпт → синтез узлов/связей.
    -   Сохранение черновиков/версий графа, откат, сравнение версий.

-   **Публикация чат-ботов: вынести embed на отдельное приложение**

    Задача: починить публикацию чат-ботов на сервере (уйти от зависимости на localhost).

    Детали:

    -   Создать `packages/embed-frontend` на базе `FlowiseEmbedReact` (обёртка и конфигурация), интеграция с нашими API.
    -   В `publish-frontend`/`template-engine-backend` обновить pipeline публикации чат-бота.

-   **Miro‑подобные возможности на холсте Space**

    Задача: добавить в Space поддержку диаграмм/карт/блок-схем с базовыми фигурами и связями.

    Детали:

    -   В `packages/updl/ui` расширить холст: фигуры, текстовые блоки, линии/стрелки, группировки, слои, масштаб/панорамирование.
    -   Экспорт/импорт диаграмм в JSON, связывание с узлами UPDL (ссылки/якоря).

-   **Публикация с предварительной генерацией (server‑side build, артефакты на сервере/S3)**

    Задача: добавить режим предварительной генерации приложений вместо потоковой генерации в браузере. По запросу публикации `template-engine-backend` генерирует целевой проект (например, PlayCanvas) на сервере, сохраняет артефакты в хранилище (S3 или локально), и при открытии пользователю выдается уже готовый собранный бандл.

    Детали:

    -   `packages/template-engine-backend`: серверный пайплайн генерации (job‑очередь, статусы jobs, логи), конфигурация таргетов (playcanvas/aframe/arjs), сохранение артефактов (S3/локально), CDN‑ссылки.
    -   `packages/publish-backend`: API для запуска/мониторинга сборки, выдачи ссылок на артефакты, управление правами доступа.
    -   `packages/publish-frontend`: UI публикации (кнопка «Сгенерировать», статус джоба, предпросмотр, кнопка «Опубликовать»), отображение ошибок/логов.
    -   Сохранить потоковую генерацию как опцию для простых кейсов; по умолчанию — предварительная генерация.

-   **Версионирование публикаций и артефактов генерации**

    Задача: ввести версии опубликованных приложений: фиксировать снимок содержимого Flow (конфигурации узлов) и, при включенной предварительной генерации, — версию сгенерированных файлов. Обеспечить переключение между версиями, pre‑release/тестовые версии и быстрый rollback.

    Детали:

    -   `publish-backend`: схемы `publication.projects`, `publication.versions`, `publication.artifacts` (хэш/метаданные/ссылки), статусы (draft/prerelease/release/deprecated), ACL.
    -   `template-engine-backend`: детерминированные сборки (контроль хэша входных данных), сохранение метаданных генерации (версия шаблона, таргет, параметры).
    -   `publish-frontend`: UI версий (создать/комментировать/сравнить/активировать/откатить), выдача предпросмотра по токену, аудит действий.

-   **Рефакторинг шаблонов публикации (workspace‑плагины)**

    Задача: вынести тяжёлые шаблоны из `publish-frontend` в отдельные workspace‑пакеты и стандартизировать их API как плагины для `template-engine-backend`. Сохранить потоковую генерацию в браузере только как режим «быстрого превью».

    Детали:

    -   Создать пакеты шаблонов: `packages/template-playcanvas-core`, `packages/template-playcanvas-mmoomm`, `packages/template-arjs-core`, `packages/template-aframe-core`.
    -   Определить плагин‑интерфейс: манифест, схема конфигурации (JSON Schema), точки расширения (генерация сцен/ассетов/скриптов), версии шаблона.
    -   `template-engine-backend`: загрузка плагинов из workspace (npm‑пакеты), выполнение генерации, валидация конфигов по схеме, возврат artifactId/URL.
    -   `publish-backend`: реестр доступных шаблонов (метаданные/версии/совместимость), выдача схем конфигов, привязка к публикациям/версиям.
    -   `publish-frontend`: UI выбора шаблона и его настроек (форма из схемы), запуск предгенерации; «потоковая генерация» оставить только для лёгкого превью в браузере.
    -   Миграция: в `packages/publish-frontend/base/src/builders/templates` оставить только слой превью, тяжёлую генерацию удалить после переноса.

---

## Этап 2. Подготовка репозитория и пакетов (ядро платформы)

-   **Создать workspace‑пакет `@universo-platformo/types` — [Выполнено]**

    Сформировать единый источник истины по типам и контрактам протокола. Разместить в `packages/universo-types`. Содержимое: доменные типы ECS (EntityId, WorldId, Transform, базовые компоненты), сетевые DTO (Intent, Ack, Snapshot, Delta, EventPayloads), общие перечисления и коды ошибок. Настроить `tsconfig`, сборку в `dist/`, экспорты из `src/index.ts`.

-   **Создать workspace‑пакет `@universo-platformo/utils`**

    Реализовать рантайм‑валидацию и общие утилиты. Разместить в `packages/universo-utils`. Содержимое: `zod`‑схемы для `Intent/Snapshot/Delta/Event`, функции сериализации дельт компонент (минимальные патчи), мерджер состояний, тайм‑синхронизатор (оценка `offset/RTT`). Экспортировать из `src/index.ts`, собрать в `dist/`.

-   **Создать workspace‑пакет `@universo-platformo/client-sdk`**

    Подготовить типобезопасный клиент для REST/WS и адаптер для Colyseus. Разместить в `packages/universo-platformo-client-sdk`. Содержимое: интерфейс транспорта (ITransport), реализация `transports/colyseus` (`joinRoom`, `sendIntent`, `onSnapshot`), подключение общих типов из `@universo-platformo/types`. Сборка браузерного ESM‑бандла для подключения в шаблон PlayCanvas. Предусмотреть скрипт генерации REST‑клиентов из OpenAPI (заготовка `scripts/generate.ts`).

-   **Актуализировать PNPM workspace‑настройки**

    Убедиться, что `pnpm-workspace.yaml` включает `packages/**`. В корневом `package.json` настроить порядок сборки: сборка пакетов ядра (`types`, `utils`, `client-sdk`) выполняется до сборки приложений `packages/*-backend`.

-   **Обновить документацию по протоколу и сетевой модели**

    Уточнить и поддерживать в актуальном состоянии спецификацию: `docs/ru/roadmap/technical-specifications/authoritative-mmo-networking.md` (тикрейт, протокол Intent/Ack/Snapshot/Delta, интерес‑менеджмент, лаг‑компенсация/реконсилиация, античит, масштабирование), `docs/ru/roadmap/technical-specifications/world-scale-and-coordinates.md` (origin rebasing), `docs/ru/applications/technical-systems/multiplayer.md` (стек PlayCanvas+Colyseus и интеграция с доменами).

-   **Интеграция пакетов в будущие приложения (подготовительные изменения)**

    Добавить зависимости `"@universo-platformo/types": "workspace:*"` и `"@universo-platformo/utils": "workspace:*"` в серверные приложения (`packages/entities-backend`, `packages/resources-backend`, `packages/multiplayer-colyseus-backend`) — для использования единых DTO и валидации. Для клиента (экспорт в PlayCanvas) предусмотреть подключение `@universo-platformo/client-sdk` через `template-engine-backend` (будет реализовано на последующих этапах).

-   **(Опционально) Создать агрегатор `@universo-platformo/core`**

    Разместить в `packages/universo-platformo-core`. Реэкспортировать части из `types` и `utils` для удобного импорта на стороне приложений. На данном этапе — необязательно, по мере необходимости.

-   **MMOOMM‑надстройки над платформой (продуктовый слой)**

    Задача: подготовить продуктовые пакеты поверх базовых, без смешивания с платформенными типами.

-   **Создать workspace‑пакет `@universo-mmoomm/types`**

    Разместить в `packages/universo-mmoomm-types`. Содержимое: доменные перечисления и типы для MMO (DamageType, Resistances, HardpointType, ModuleSlotType, OrderType, WalletCurrency (включая Inmo), Combat/Economy/Event payloads). Экспортировать из `src/index.ts`, придерживаться семантического версионирования, не смешивать с базовыми платформенными типами.

-   **Создать workspace‑пакет `@universo-mmoomm/utils`**

    Разместить в `packages/universo-mmoomm-utils`. Содержимое: валидаторы доменных инвариантов (экономика — идемпотентность/двойная запись; боёвка — диапазоны/кулдауны/энергия), маппинги визуальных состояний по порогам (Visual ↔ Health/Integrity), вспомогательные функции для сериализации доменных событий. Экспортировать из `src/index.ts`.

-   **Создать workspace‑пакет `@universo-mmoomm/client-sdk`**

    Разместить в `packages/universo-mmoomm-client-sdk`. Содержимое: расширения над базовым SDK — высокоуровневые методы (`fire`, `useModule`, `placeOrder`, `cancelOrder`, `transfer`, и т.д.), типизированные подписки на `combat.*`, `trading.*`, `economy.*`. Под капотом — использование `@universo-platformo/client-sdk` (ITransport/Room API). Сборка браузерного ESM‑бандла для подключения в экспорт PlayCanvas.

-   **(Опционально) Создать агрегатор `@universo-mmoomm/core`**

    Разместить в `packages/universo-mmoomm-core`. Реэкспортировать части из `@universo-mmoomm/types` и `@universo-mmoomm/utils` для удобного импорта на стороне приложений/клиента. Необязательно на старте.

-   **Актуализировать PNPM workspace‑настройки (MMOOMM)**

    Убедиться, что `pnpm-workspace.yaml` включает шаблоны `packages/universo-mmoomm-*`. В корневом `package.json` задать порядок: сборка платформенных пакетов (`@universo-platformo/*`) → сборка MMOOMM‑пакетов (`@universo-mmoomm/*`) → сборка `packages/*-backend`.

-   **Интеграция пакетов в приложения (MMOOMM)**

    Для серверов использовать платформенные типы/утилиты, а доменные типы MMOOMM — в соответствующих сервисах (например, `combat-backend`, `economy-backend`). Для клиента (экспорт в PlayCanvas) — подключать оба слоя SDK: базовый `@universo-platformo/client-sdk` и надстройку `@universo-mmoomm/client-sdk` через `template-engine-backend` (конфиг экспорта выберет нужные рантаймы/транспорты).

---

## Этап 3. Бэкенд ядра данных (ECS + Ресурсы)

-   **Создать `packages/entities-backend` (ядро ECS)**

    Задача: хранение канонического состояния сущностей по модели ECS (Entity + Components + Relations), инстансирование из версий ресурсов, представление деревьев сборки.

    Детали:

    -   Схема БД: `ecs.entities`, `ecs.components` (JSONB), `ecs.entity_relations`.
    -   REST (v1): `POST /api/v1/entities/instantiate`, `GET /api/v1/entities/:id`, `GET /api/v1/entities/:id/tree`, `PATCH /api/v1/entities/:id`.
    -   Назначение: создать Entity из `resourceVersionId`, хранить компоненты (минимум: Transform/Visual/Health), строить дерево по BOM, возвращать дерево/срез состояния.

-   **Создать `packages/resources-backend` (каталог ресурсов/версий/BOM)**

    Задача: канонический справочник Resource → ResourceVersion (immutable) → BOM (состав) и Units, публикации версий и валидации DAG.

    Детали:

    -   Схема БД: `resources.resource`, `resources.resource_version` (semver, status), `resources.resource_bom` (qty/unit/is_optional/is_alternative_group), `resources.units`.
    -   REST (v1): каталоги ресурсов, версии (draft→publish), CRUD BOM, DAG‑валидация (запрет циклов), конверсия единиц.
    -   Назначение: исходные данные для инстансирования сущностей и генерации клиентов.

-   **Интеграции**

    -   `template-engine-backend`: берёт `ResourceVersion/BOM` → материализует сцену (SP/MP таргеты).
    -   `multiplayer-backend` (см. Этап 4): будет опираться на ECS для формирования снапшотов/дельт и авторитетного состояния.
    -   Доменные сервисы (`ships-backend`, `economy-backend`, `combat-backend`): добавляют собственные компоненты/правила поверх ECS.

-   **Критерии готовности**

    -   Из `resourceVersionId` создаётся дерево сущностей по BOM; агрегаты (масса/объём/стоимость) считаются (минимальный набор).
    -   REST покрывает `instantiate/get/tree/update`; DAG‑валидация не допускает циклы в BOM.

---

## Этап 4. Авторитетный мультиплеер (Colyseus)

-   **Создать `packages/multiplayer-colyseus-backend` (Node/TS + Colyseus + Redis)**

    Задача: реализовать авторитетный сервер реального времени: комнаты по миру/инстансу, фиксированный тик, снапшоты/дельты, интерес‑менеджмент, античит и лаг‑компенсацию.

    Детали:

    -   Комнаты per‑мир/инстанс; фиксированный тик ~30 Гц, снапшоты 10–20 Гц, дельты изменений
    -   Интерес‑менеджмент (grid/октодерево), подписки на ближние сущности
    -   Протокол: intents (seq, tClient), `ack`, `snapshot`, `delta`, `event`
    -   Античит: лимиты скорости/ускорения/энергии/кулдаунов, верификация JWT при join, rate‑limit
    -   Лаг‑компенсация: rewind по `tClient` для `fire`/hitscan
    -   Метрики: тик‑длительность, RTT, размер дельт, reconciliation rate, пропуски сообщений

-   **Интеграции (сервер/клиент)**

    -   Зависит от Этапа 3: `entities-backend` и `resources-backend` должны быть доступны (каноническое состояние ECS и BOM)
    -   `auth-backend`/Supabase: JWT при join, скоупы доступа
    -   `entities-backend`/`resources-backend`: чтение/синхронизация состояния ECS, деревья по BOM
    -   `template-engine-backend`: инъекция транспортного клиента (Colyseus) и переключение SP/MP в экспортируемом проекте

-   **Критерии готовности**

    -   Несколько клиентов видят одинаковое состояние; невозможно «ускоряться/телепортироваться» вне правил
    -   Попадания и урон считаются на сервере; лаг‑компенсация даёт корректные результаты при типичных RTT

-   **Ссылки**

    -   Идеология предикции/rewind: https://github.com/GameNetworking/NetworkSynchronizer/discussions/116
    -   PlayCanvas × Colyseus: https://developer.playcanvas.com/tutorials/real-time-multiplayer-colyseus/

---

## Этап 5. Клиент PlayCanvas: предикция/реконсилиация

-   **Включить клиентский модуль в `template-engine-backend`**

    Задача: встроить в экспортируемый проект PlayCanvas клиентский рантайм, сглаживающий сетевую задержку: локальная предикция, реконсилиация по ack/snapshot, интерполяция/экстраполяция чужих сущностей, origin rebasing для больших сцен.

    Детали:

    -   Colyseus client; буферизация инпутов (seq, clientTime), отправка intents, хранение до ack
    -   Интерполяция/экстраполяция чужих сущностей из снапшотов/дельт (интерполяционный буфер 100–200 мс)
    -   Реконсилиация: откат к подтверждённому состоянию и реплей локальных инпутов
    -   Origin rebasing ("move the world, not the user")
    -   Тайм‑синхронизация: оценка offset/RTT, метки времени в инпутах/снапшотах
    -   Интеграция в game loop PlayCanvas через скриптовый компонент; переключение SP/MP через env

-   **Интеграции**

    -   Зависит от Этапа 4 (`multiplayer-backend`): авторитетный сервер должен быть доступен
    -   Использует `@universo-platformo/client-sdk` (транспорт Colyseus)
    -   Интеграция с `template-engine-backend`: автоматическая инъекция рантайма в экспортируемый проект

-   **Критерии готовности**

    -   Плавное движение при 80–120 мс RTT; коррекции без рывков; стабильный FPS
    -   Низкий процент жёстких откатов; отсутствует заметная «резинка»

-   **Ссылки**

    -   Идеология предикции/rewind: https://github.com/GameNetworking/NetworkSynchronizer/discussions/116
    -   PlayCanvas × Colyseus: https://developer.playcanvas.com/tutorials/real-time-multiplayer-colyseus/

---

## Этап 6. Минимальные домены для геймплея (базовые)

-   **Создать `packages/ships-backend` (минимум)**

    Задача: предоставить базовый домен «корабли» поверх ECS без привязки к конкретной игре.

    Детали:

    -   Каталоги: типы кораблей, базовые модули/характеристики (масса, энергия, слоты)
    -   Компонент ECS: `Ship` (ядро параметров), валидация простого фиттинга
    -   REST (v1): GET каталоги, POST проверка фиттинга, GET/PUT компонент `Ship` сущности

-   **Создать `packages/combat-backend` (минимум)**

    Задача: серверные формулы урона/резистов и применение урона к ECS‑состоянию.

    Детали:

    -   Модель урона: shield/armor/hull + резисты, кулдауны/стоимость выстрела
    -   REST (v1): POST `/combat/apply` {attackerId, targetId, weaponId, tClient?} → изменения Health/Integrity через `entities-backend`
    -   Публикация событий: `combat.hit`, `combat.destroyed`

-   **Создать `packages/economy-backend` (минимум)**

    Задача: кошельки/валюты и безопасные денежные операции с инвариантами.

    Детали:

    -   Схема: `economy.currencies`, `economy.wallets`, `economy.transactions` (двойная запись)
    -   REST (v1): GET balance, POST transfer, POST exchange (идемпотентность), аудит
    -   Инварианты: закон сохранения, атомарность, ретраи без двойных списаний

-   **Интеграции**

    -   `multiplayer-backend`: на интенты `fire/use_module` вызывает `combat-backend`/`ships-backend`; транзакции — через `economy-backend`
    -   `entities-backend`: чтение/запись компонент `Ship`, `Health/Integrity`
    -   `template-engine-backend`: может подтягивать каталоги для клиентских UI (опционально)

-   **Критерии готовности**

    -   Стрельба и базовый урон рассчитываются на сервере и отражаются в ECS‑состоянии
    -   Денежные операции проходят через ledger с идемпотентностью и аудитом

Примечание: продукт‑специфичные расширения (например, `packages/mmoomm-ships-backend`, `packages/mmoomm-combat-backend`) могут быть добавлены позднее как оверлеи поверх базовых доменов, с собственными каталогами/балансом и независимым версионированием.

---

## Этап 7. Публикация/конфигурация/SDK

-   **Подготовить `@universo-platformo/client-sdk` (браузерный ESM)**

    Задача: предоставить типобезопасный клиент для REST (из OpenAPI `packages/*-backend`) и транспорт Colyseus (Room API), который автоматически встраивается в экспортируемые проекты.

    Детали:

    -   Генерация REST‑клиентов по OpenAPI; унификация вызовов (auth headers, идемпотентность)
    -   Транспорт Colyseus: `joinRoom/sendIntent/onSnapshot` с типами DTO
    -   Бандл браузерного SDK для подключения `template-engine-backend`

-   **`publish-frontend`: UI конфигурации публикаций**

    Задача: единое место настройки таргета/шаблона, ENV (API/WS endpoints), профилей (dev/stage/prod) и запуска публикации.

    Детали:

    -   Форма настроек из схем шаблонов; выбор профиля окружения
    -   Запуск предгенерации/релиза; отображение статусов jobs/логов (через `publish-backend`)
    -   Переключение версий публикаций (см. Этап 1)

-   **`template-engine-backend`: инъекция SDK и ENV в сборку**

    Задача: при экспорте подключать `@universo-platformo/client-sdk`, подставлять ENV и выдавать готовые артефакты.

    Детали:

    -   Инъекция SDK и конфигов в проект PlayCanvas (и другие таргеты)
    -   Безопасность: секреты остаются на сервере; в клиент попадают только публичные параметры

-   **Интеграции**

    -   Зависит от Этапа 1: серверная предгенерация и версии публикаций должны быть доступны (`template-engine-backend`, `publish-backend`)
    -   Использует плагин‑шаблоны (`packages/template-*`) и реестр шаблонов (`publish-backend`)

-   **Критерии готовности**

    -   Проект экспортируется из Space одной кнопкой и поднимается с мультиплеером по указанным эндпоинтам
    -   Профили окружений работают; возможен быстрый откат к предыдущей версии

---

## Этап 8. Наблюдаемость и тестирование

-   **Метрики и наблюдаемость**

    Задача: внедрить сбор метрик, логов и трассировок для контроля качества MMO и быстрого реагирования на деградации.

    Детали:

    -   Метрики: тик‑длительность/джиттер, RTT, размер/частота дельт, reconciliation rate, пропуски сообщений
    -   Нагрузки: CPU/RAM/GC, задержки интерес‑менеджмента, ошибки ACL/RLS
    -   Экономика: инварианты (сход балансов, идемпотентность транзакций), задержки клиринга
    -   Логи/трейсинг: корреляция (trace/span), аудит доменных операций (entities/resources/combat/economy)
    -   Алертинг: превышение порогов (RTT, тик > budget), нарушение инвариантов, всплески rate‑limit

-   **Нагрузочные и регрессионные тесты**

    Задача: подготовить сценарии нагрузки и регрессии для мультиплеера, экономики и боёвки.

    Детали:

    -   WS‑генератор ботов: интенты (движение/стрельба/модули), длинные сессии и бурст‑нагрузка
    -   Combat‑replay: детерминированные повторы боёв, проверка лаг‑компенсации в окне T
    -   Property‑based тесты для экономики: двойная запись, идемпотентность, обмены

-   **Интеграции**

    -   Использует `multiplayer-backend` (Этап 4), клиентский рантайм (Этап 5), домены (Этап 6)
    -   Техническая база: Prometheus/Grafana или Otel‑совместимые метрики; централизованное логирование
    -   Документация: см. `roadmap/technical-specifications/observability.md` и `testing-strategy.md`

-   **Критерии готовности**

    -   Достигаются SLO по лагу и пропускам при N одновременных ботах; тик‑длительность в пределах бюджета
    -   Нулевые расхождения леджера и успешные property‑based тесты экономики
    -   Низкий процент «жёстких» откатов; алерты настроены и верифицированы

---

## Этап 9. Масштабирование и шардирование

-   **Горизонтальная масштабируемость (Redis presence/pubsub)**

    Задача: масштабировать авторитетный мультиплеер по процессам/нодам/регионам без потери согласованности.

    Детали:

    -   Colyseus: включить RedisPresence/RedisDriver для кластерной работы (multi‑process/node)
    -   Дискавери комнат: реестр активных `roomId → host/node`, sticky‑сессии на LB
    -   Балансировка: autoscale по метрикам (rooms/players/tick‑budget), безопасный drain комнат

-   **Шардирование миров/инстансов**

    Задача: разделить нагрузку по shard‑ключу и обеспечить независимость инстансов.

    Детали:

    -   Ключ: `worldId:instanceId[:region]`; политика размещения (static/dynamic)
    -   Placement‑координатор: сервис назначения шардов и выдачи адресов комнат
    -   Изоляция: событийная шина между шардами только для кросс‑доменных событий (чат/экономика)

-   **Миграция между шардами (ворота/зоны)**

    Задача: реализовать «handover» игрока/корабля при переходе через ворота/границы зон.

    Детали:

    -   Протокол: `prepareTransfer(roomA→roomB)` → короткоживущий `transferToken` (JWT)
    -   Граница тика: freeze на границе, сериализация минимального состояния (Transform, Velocity, базовые компоненты)
    -   Двухфазность: краткая «двойная» сессия для сглаживания (ghost/bridge 1–2 тика), затем финализация владения сущностью
    -   Клиент: `leave room A → join room B` по `transferToken` с продолжением seq

-   **Периодические снапшоты состояния комнат в БД**

    Задача: обеспечить быстрый рестарт комнат и офлайн‑аналитику.

    Детали:

    -   Периодичность: раз в N секунд сохранять снапшот ECS‑состояния (минимальный срез + журнал событий за окно)
    -   Хранилище: Postgres (Supabase) для метаданных/журналов, бинарные блобы допустимы (сжатие)
    -   Рестарт: восстановление «с последнего снимка + журнал»; контроль версии схемы снапшота

-   **Интеграции**

    -   Зависит от Этапа 4 (multiplayer‑srv), Этапа 5 (клиент), Этапа 6 (домены), Этапа 8 (наблюдаемость)
    -   `auth-backend`: выдача `transferToken`; `entities-backend`: сериализация/десериализация компонент
    -   LB/Ingress (sticky WS), Redis‑кластер, координатор размещения (как часть `multiplayer-backend` или отдельный `world-coordinator-backend`)

-   **Критерии готовности**

    -   Линейный рост вместимости при добавлении нод; тик‑бюджет соблюдается под нагрузкой
    -   Переход ворот/зон без разрыва: миграция < T мс, без потери владения/событий
    -   Комната восстанавливается из снапшота за ≤ S секунд, потеря состояния ограничена окном журнала

---

Примечание: все пакеты размещаются в `packages/` (а не в `packages/`), чтобы полностью отделить ядро платформы от исходной кодовой базы Flowise и упростить будущий вынос в отдельные репозитории.
