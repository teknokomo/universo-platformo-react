# üö® CRITICAL SECURITY VULNERABILITY: Hardcoded Fallback Session Secret Enables Session Hijacking

## Severity: CRITICAL üî¥

## Summary

The application uses a **hardcoded fallback session secret** (`'change-me'`) when the `SESSION_SECRET` environment variable is not configured. This creates a critical security vulnerability that allows attackers to:

1. **Forge session cookies** with valid signatures
2. **Hijack user sessions** and impersonate any user
3. **Access Supabase JWT tokens** (access and refresh tokens) stored in sessions
4. **Bypass authentication completely**

## Affected Code

**File**: `packages/flowise-server/src/index.ts`  
**Lines**: 168-192

```typescript
const sessionSecret = process.env.SESSION_SECRET
if (!sessionSecret) {
    logger.warn('‚ö†Ô∏è [auth] SESSION_SECRET is not set. Falling back to insecure development secret.')
}

// ... cookie configuration ...

this.app.use(
    session({
        name: process.env.SESSION_COOKIE_NAME ?? 'up.session',
        secret: sessionSecret ?? 'change-me',  // ‚ö†Ô∏è CRITICAL VULNERABILITY
        resave: false,
        saveUninitialized: false,
        cookie: cookieConfig,
    })
)
```

## Vulnerability Details

### What's Stored in Sessions

Based on the authentication implementation in `packages/auth-srv/base/src/services/supabaseSession.ts`, sessions store highly sensitive data:

```typescript
req.session.tokens = { 
    access: data.session.access_token,   // Supabase JWT access token
    refresh: data.session.refresh_token, // Supabase JWT refresh token
    exp: payload?.exp                    // Token expiration
}
```

### Attack Scenario

1. **Attacker discovers** the application is running without `SESSION_SECRET` set (common in misconfigured deployments)
2. **Attacker knows** the fallback secret is `'change-me'` (visible in public source code)
3. **Attacker crafts** a valid session cookie using the known secret
4. **Attacker includes** forged Supabase tokens in the session
5. **Attacker gains** full authenticated access to any user account

### Why This is Critical

1. **Session cookies are signed** with the secret to prevent tampering
2. **Known secret = no protection** - anyone can forge valid signatures
3. **Production deployments** may run with this fallback if environment variables are not properly configured
4. **Silent failure** - only logs a warning but continues running
5. **Supabase tokens exposed** - complete authentication bypass

## Current Behavior

When `SESSION_SECRET` is not set:
- ‚úÖ Logs a warning message
- ‚ùå **Continues to run** with insecure `'change-me'` secret
- ‚ùå **No startup failure** or error
- ‚ùå **Production traffic accepted** with compromised security

## Security Impact

| Impact Area | Severity | Details |
|-------------|----------|---------|
| **Authentication** | CRITICAL | Complete bypass possible |
| **Session Hijacking** | CRITICAL | Any user session can be forged |
| **Data Access** | CRITICAL | Full access to user data via forged sessions |
| **Token Exposure** | CRITICAL | Supabase JWT tokens compromised |
| **User Privacy** | CRITICAL | All user accounts vulnerable |

## Proposed Solution

### Option 1: Fail Fast (Recommended) ‚úÖ

**Refuse to start** if `SESSION_SECRET` is not configured:

```typescript
const sessionSecret = process.env.SESSION_SECRET
if (!sessionSecret) {
    logger.error('‚ùå [auth] SESSION_SECRET is not set. Application cannot start without a secure session secret.')
    throw new Error('Auth configuration error: SESSION_SECRET is required')
}

this.app.use(
    session({
        name: process.env.SESSION_COOKIE_NAME ?? 'up.session',
        secret: sessionSecret, // No fallback - fails earlier if undefined
        resave: false,
        saveUninitialized: false,
        cookie: cookieConfig,
    })
)
```

**Benefits**:
- ‚úÖ Forces proper configuration before deployment
- ‚úÖ Prevents accidental production deployment with insecure settings
- ‚úÖ Clear error message guides developers
- ‚úÖ Similar to existing `SUPABASE_JWT_SECRET` validation (line 152-156)

### Option 2: Generate Random Secret with Warning ‚ö†Ô∏è

**Generate a random secret** at startup if not configured (development only):

```typescript
const sessionSecret = process.env.SESSION_SECRET || (() => {
    const randomSecret = require('crypto').randomBytes(64).toString('hex')
    logger.warn('‚ö†Ô∏è [auth] SESSION_SECRET is not set. Generated temporary secret for this instance.')
    logger.warn('‚ö†Ô∏è [auth] This secret will change on restart. Set SESSION_SECRET in production!')
    return randomSecret
})()

this.app.use(
    session({
        name: process.env.SESSION_COOKIE_NAME ?? 'up.session',
        secret: sessionSecret,
        resave: false,
        saveUninitialized: false,
        cookie: cookieConfig,
    })
)
```

**Benefits**:
- ‚úÖ Better than hardcoded secret
- ‚úÖ Each instance has unique secret
- ‚ö†Ô∏è Sessions invalidated on restart
- ‚ö†Ô∏è Not suitable for multi-instance deployments

**Drawbacks**:
- ‚ùå Still allows running without proper configuration
- ‚ùå Sessions lost on restart
- ‚ùå Won't work in load-balanced environments

### Recommended Approach

**Option 1 (Fail Fast)** is strongly recommended because:

1. **Consistency** - Matches existing validation for `SUPABASE_JWT_SECRET`
2. **Security first** - Prevents deployment with insecure configuration
3. **Clear guidance** - Developers get immediate feedback
4. **Production ready** - Forces proper setup before going live

## Implementation Checklist

- [ ] Remove hardcoded `'change-me'` fallback
- [ ] Add startup validation for `SESSION_SECRET`
- [ ] Throw error if `SESSION_SECRET` is not set
- [ ] Update `.env.example` with clear instructions
- [ ] Update documentation (README.md, setup guides)
- [ ] Add migration guide for existing deployments
- [ ] Test startup behavior without environment variable
- [ ] Verify error messages are clear and actionable

## Documentation Updates Needed

1. **`.env.example`** - Add prominent comment:
   ```bash
   # Session secret for secure cookie signing (REQUIRED for production)
   # Generate with: openssl rand -base64 64
   SESSION_SECRET=change_me_to_random_secure_value
   ```

2. **README.md** - Add to required environment variables section

3. **Deployment guides** - Emphasize `SESSION_SECRET` requirement

## Testing

### Verify Fix

```bash
# Should fail to start
unset SESSION_SECRET
pnpm start

# Should succeed with proper error message:
# ‚ùå [auth] SESSION_SECRET is not set. Application cannot start without a secure session secret.
# Error: Auth configuration error: SESSION_SECRET is required
```

### Generate Secure Secret

```bash
# Generate a secure random secret
openssl rand -base64 64

# Or using Node.js
node -e "console.log(require('crypto').randomBytes(64).toString('base64'))"
```

## Related Security Considerations

While fixing this issue, also review:

1. **Other environment variables** - Are there other hardcoded fallbacks?
2. **Secret rotation** - Document how to rotate `SESSION_SECRET`
3. **Multi-instance deployments** - All instances must share the same secret
4. **Secret management** - Consider using secret management services (AWS Secrets Manager, HashiCorp Vault, etc.)

## References

- [Express Session Security](https://github.com/expressjs/session#secret)
- [OWASP Session Management](https://cheatsheetseries.owasp.org/cheatsheets/Session_Management_Cheat_Sheet.html)
- [CWE-798: Use of Hard-coded Credentials](https://cwe.mitre.org/data/definitions/798.html)

## Labels

- `security` - Security vulnerability
- `critical` - Critical severity issue
- `bug` - Bug in existing code
- `authentication` - Related to authentication system
- `configuration` - Configuration issue

## Priority

**URGENT** - This should be fixed before any production deployment.

---

**Discovered during**: Security audit  
**Date**: 2025-11-15  
**Reporter**: Security Audit Agent
